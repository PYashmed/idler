# 动态规划初窥（0）

---
>那是一个月黑风高的夜晚，复习CS-BIO的猫妃拿出了一道[基因匹配](https://www.luogu.com.cn/problem/P1140)，还没复习到动态规划的我瑟瑟发抖，旋即将复习计划提前...
---

## 从Fibonacci说起-[509Fibonacci](https://leetcode.cn/problems/fibonacci-number/)

题目不难，核心代码为一次递推

```c
f[i]=f[i-1]+f[i-2];
```

初始状态`f[0]` `f[1]`

```c
int f[max]={0,1};
```

**递推是一种最简单的状态转移，`f[i]`便是一种状态，递推公式即为状态转移方程**

### [爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

从第0阶开始，每次可以爬1阶或者2阶，求爬到n层的方案数

`f(i)` 为爬到第`i`层的方案数目，则有两种方法到达第`i`层
从`f(i-1)`或`f(i-2)`到达`i`

```c
f[i]=f[i-1]+f[i-2];
```

初始状态`f(0)` `f(1)`为从0到0和0到1的方案数，均为1

```c
int f[max]={1,1};
```

理解：状态`f(i)`可由`f(i-1)` `f(i-2)`得到，递推公式即为状态转移方程

### [最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)(带权问题)

同样的爬楼梯，但给定数组`cost[i]`代表从第`i`层向上爬所需要支付的费用，可以自主选择从`0`或`1`阶开始，问到达第n层所需要的最小费用是多少

状态分析：`f[i]` 只能从 `f[i-1]` `f[i-2]`得到
从`i-1`需要支付`cost[i-1]`,同理`f[i-2]`
最优解即为两种方法中的最小值

```c
f[i]=min(f[i-1]+cost[i-1],f[i-2]+cost[i-2]);
```

初始状态
可选择从0，1开始，所以肯定不会出现`0 -> 1`
所以`f[0]=0` `f[1]=0`

```c
int f[max]={0,0};
```

### [最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

给定数组`nums[i]`求其中最大连续子数组和

状态`f[i]`为找到数组中第`i` 个元素时的最大子数组和
则有两种情况

1. `i` 与前面 `i-1`号连着
2. `i` 与前面 `i-1`号不相连， 即取到`i`时，`nums[i]` （一个元素）为最大子数组

```c
f[i]=max(f[i-1]+nums[i],nums[i]);
```

在转移过程中可能会出现`f[i]`递减情况，（当`nums[i]`小于0）所以`f[n]`不一定是最大子数组和
定义`maxvalue`，每次计算出`f[i]`后进行比较，起始设定为`nums[0]`

```c
int maxvalue=nums[0];
```

循环内（每次计算出`f[i]`后）比较

```c
maxvalue=max(maxvalue,f[i]);
```

## 动态规划

动态规划题目大致思路

+ 设计状态
+ 写出状态转移方程
+ 设定初始状态
+ 执行状态转移
+ 返回解

### 回归到CS-BIO的基因匹配问题

已知基因匹配权重
`-` 代表空碱基,即碱基对有五种匹配方式如下表

|       |   -   |   A   |   T   |   C   |   G   |
| :---: | :---: | :---: | :---: | :---: | :---: |
|   -   |   0   |  -5   |  -5   |  -5   |  -5   |
|   A   |  -5   |   2   |  -7   |  -5   |  -7   |
|   T   |  -5   |  -7   |   2   |  -7   |  -5   |
|   C   |  -5   |  -5   |  -7   |   2   |  -7   |
|   G   |  -5   |  -7   |  -5   |  -7   |   2   |

对于给定的两个基因序列，试图找到匹配度最高的匹配方式
可以人工插入空碱基，但ATCG相对顺序不能改变
栗子：`CCTG` `AGCC` 可以向其中插入任意个空碱基来获得最高匹配度`C--C-T--G--` `-A-G--C---C`(瞎写的)

对于给定的两个序列，每一个位置的匹配有三种可能性

+ `序列1`的下一个非空碱基匹配空碱基`-`
+ `序列2`的下一个非空碱基匹配空碱基`-`
+ `序列1`的下一个非空碱基匹配`序列2`的下一个非空碱基

>`ACTG`与`AGCC`,第一位置匹配
>
>+ `A` === `-` >>  `-5`
>+ `-` === `A` >>  `-5`
>+ `A` === `A` >>  `2`
>三者取最优（最大），即第一位置匹配为`A` === `A`
>
>第二位置匹配
>
>+ `C` === `-` >>  `-5`
>+ `-` === `G` >>  `-5`
>+ `C` === `G` >>  `-7`
>正序思考时，两种方式均要考虑

**状态分析**：`f[i][j]`为匹配到`序列1`的第`i`个非空碱基，`序列2`的第`j`个非空碱基时的最高匹配度
根据分析，有如下三种情况
`l1[i]` 为将`ATCG`转化为`1234`后的碱基序列
`map[i][j]`为权重表格

```c
f[i][j]=max(f[i-1][j]+map[l1[i]][0],f[i][j-1]+map[0][l2[j]],f[i-1][j-1]+map[l1[i]][l2[j]])
```

解题中注意边界赋值`f[i][0]` `f[0][j]`
`f[0][0]`根据意义定义为`0`

#### 输出路径（即匹配方式）的多解

在本题中，存在多种匹配方式情况
`AAG` `AGC` 最佳匹配有两种 `AA-G` `-AGC` 或 `AA-G` `A-GC`

不难看出，手动计算匹配方式时只需要得到一种匹配方式，其余按照规律交换即可

+ 其中一序列存在连续相同非空碱基
+ 上述片段对应的另一序列片段中存在空碱基
+ 可以随意移动空碱基排列情况来得到新的解
